import torch.fx as fx
from typing import List

from quantlib.newediting.graphs.nn.epstunnel import EpsTunnel
from ..epspropagation.epspropagator import EpsPropagator, is_eps_annotated
from ...editors.editors import ApplicationPoint, Rewriter


class EpsTunnelInserter(Rewriter):

    def __init__(self):
        name = 'EpsTunnelInserter'
        super(EpsTunnelInserter, self).__init__(name)

    def find(self, g: fx.GraphModule) -> List[ApplicationPoint]:
        apcores = list(filter(lambda n: EpsPropagator.returns_qtensor(n), g.graph.nodes))
        aps = [ApplicationPoint(rewriter=self, graph=g, apcore=a) for a in apcores]
        return aps

    def _check_aps(self, g: fx.GraphModule, aps: List[ApplicationPoint]) -> None:
        pass  # TODO: verify that application points do not overlap and that they were generated by this Rewriter

    def _apply(self, g: fx.GraphModule, ap: ApplicationPoint) -> fx.GraphModule:

        n = ap.apcore
        downstream_nodes = {u for u in n.users if is_eps_annotated(u)}

        for u in downstream_nodes:

            new_module = EpsTunnel(n.meta['eps'])

            self._counter += 1
            new_target = '_'.join([self._name.upper(), new_module.__class__.__name__.upper(), str(self._counter)])

            g.add_submodule(new_target, new_module)
            with g.graph.inserting_before(u):
                new_node = g.graph.call_module(new_target, args=(n,))
            u.replace_input_with(n, new_node)

        return g
