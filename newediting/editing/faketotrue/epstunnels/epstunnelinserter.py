import torch.fx as fx
from typing import List

from quantlib.newediting.graphs.nn.epstunnel import EpsTunnel
from ..epspropagation.epspropagator import EpsPropagator, is_eps_annotated
from ...editors.editors import ApplicationPoint, Rewriter


class EpsTunnelInserter(Rewriter):

    def __init__(self):
        name = 'EpsTunnelInserter'
        super(EpsTunnelInserter, self).__init__(name)

    def find(self, g: fx.GraphModule) -> List[ApplicationPoint]:
        apcores = list(filter(lambda n: EpsPropagator.returns_qtensor(n), g.graph.nodes))
        aps = [ApplicationPoint(rewriter=self, graph=g, apcore=a) for a in apcores]
        return aps

    def _check_aps(self, g: fx.GraphModule, aps: List[ApplicationPoint]) -> None:
        pass  # TODO: verify that application points do not overlap and that they were generated by this `Rewriter`

    def _apply(self, g: fx.GraphModule, ap: ApplicationPoint) -> fx.GraphModule:

        n = ap.apcore
        eps = n.meta['eps']

        # insert an `EpsTunnel` immediately after the `fx.Node` emitting a fake-quantised `torch.Tensor`
        self._counter += 1

        new_module = EpsTunnel(eps)
        new_target = '_'.join([self._name.upper(), new_module.__class__.__name__.upper(), str(self._counter)])

        g.add_submodule(new_target, new_module)
        with g.graph.inserting_after(n):
            new_node = g.graph.call_module(new_target, args=(n,))
        downstream_nodes = list(u for u in n.users if u != new_node)  # TODO: this is ugly, but at the same time `n.replace_all_uses_with` leads to a "circular dependency" where `new_node` becomes an input to itself...
        for u in downstream_nodes:
            u.replace_input_with(n, new_node)

        # if the node is used by multiple downstream nodes, push a different `EpsTunnel` copy down each path
        downstream_qnodes = {u for u in new_node.users if is_eps_annotated(u)}
        if len(downstream_qnodes) > 1:

            for u in downstream_qnodes:

                self._counter += 1

                new_module_copy = EpsTunnel(eps)
                new_target_copy = '_'.join([self._name.upper(), new_module_copy.__class__.__name__.upper(), str(self._counter)])

                g.add_submodule(new_target_copy, new_module_copy)
                with g.graph.inserting_before(u):
                    new_node_copy = g.graph.call_module(new_target_copy, args=(new_node,))
                u.replace_input_with(new_node, new_node_copy)

        return g
